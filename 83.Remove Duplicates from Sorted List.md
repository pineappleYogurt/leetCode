# step1
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        copy = head
        while copy and copy.next:
            if copy.val == copy.next.val:
                copy.next = copy.next.next
            else:
                copy = copy.next
        return head
```
#### 思考ログ
- おおよそ解法は思いついたが時間内にコードを書けなかったのでaraiさんの解法を確認
- 現在の値と次の値を比較するところをisで書いたが今回の場合アドレスの一致ではなく値の一致を見ないとダメなので==にしないとダメ

# step2
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        copy = head
        while copy and copy.next:
            if copy.val == copy.next.val:
                copy.next = copy.next.next
                continue
            copy = copy.next
        return head
```
再帰でも解いてみる
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        if head.val == head.next.val:
            head = self.deleteDuplicates(head.next)
        else:
            head.next = self.deleteDuplicates(head.next)
        return head
```
#### 思考ログ
- 計算量
    - time complexity：o(n)
    - space complexity：o(1)
- 与えられたオブジェクトに破壊的な変更を行うのは実務ではあまりやらないので違和感があったが、コーディングテストではその辺りは気にしないでいい？
    - pythonの変数から変数への代入は参照渡しになっている
    - pythonのcopyについて調べてみる　https://docs.python.org/ja/3/library/copy.html
        - A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.
        - A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.
    - deep copyを使えば与えられたオブジェクトの破壊的な変更は防げそう
- 過去解いた人のPRを見てみる
    - 再帰で解く方法もあるそう
        - 普段あまり再帰でコードを書く機会がないが再帰でしか書けないコード以外で再帰を使う意味はあるのか
        - 個人的には再帰に慣れていないからか読みにくい
        - nodchipさんのコメントでも以下のようにあった
        >あくまで個人的な意見なのですが、ループと再帰で同じ処理が実装できる場合は、ループのほうが読んでいて認知負荷が低いように思います。個人的には step2 の回答のほうが好みです。
        - 再帰での解法についてodaさんが例え話で解説していた。他のところでも自然言語で説明するということがよく挙げられているが、自分と専門家集団との差の一つはここにあるのかもしれない
    - 変数名に対するodaさんのコメント
        - >本当に上から読んでいって明らかならば node だけでもいいと思うんですよね。読み手に何を伝えたいか次第です。for i in range(len(array)): と書かれていたら、添字の配列であろうとほぼ確信して次にいけるわけです。これが長くても迷彩か擬態にしかなりません。
        - 変数名あまり考えずにわかりやすければと長くつけることが多いが、長いことがノイズになることもある。
        - 命名については過去のPRでもよく議論されているがこれはコーディングテストでも重要なポイントなのか、単に突っ込みやすいからなのか
    - hayashi-ayさんのコメントにあった以下のやり方だと、elseがなくなりよりシンプルにできる
        - >正常系では、1回のループでノードが１つ進むとするとif文はcontinueして、elseを消すのもありかもしれないです。
        - この書き方でシンプルになったがどちらの方がわかりやすいのかは人によるかもしれない
        - 議論されている箇所があった（https://github.com/tarinaihitori/leetcode/pull/3/files#r1808004503）、自分としても趣味の範囲という気がする
    - pythonにはセイウチ演算子なるものがあり代入式が使えるそう、ただ認知負荷が高い気がする。
        - https://peps.python.org/pep-0572/
# step3
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        copy = head
        while copy and copy.next:
            if copy.val == copy.next.val:
                copy.next = copy.next.next
            else:
                copy = copy.next
        return head
```
#### 思考ログ
- コード1行1行声に出し誰かに説明しながらコードを解いてみた
- 他の人のコードを見る中で再帰やelse無しの書き方を知ったが、結局単純なif-elseの書き方が口頭で説明しやすかった
